# Solar Power Prediction with Bigger Dataset + Improved Models
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split, cross_val_score, GridSearchCV
from sklearn.ensemble import RandomForestRegressor, RandomForestClassifier
from sklearn.metrics import mean_squared_error, r2_score, accuracy_score
import matplotlib.pyplot as plt
# 1. Generate Synthetic Dataset (500 samples)
np.random.seed(42)
temperature = np.random.randint(15, 45, 500)   # Â°C
humidity = np.random.randint(20, 90, 500)      # %
wind_speed = np.random.randint(2, 25, 500)     # km/h
# A synthetic function for solar output (depends on temperature, humidity, wind)
solar_output = (
    0.15 * temperature 
    - 0.05 * humidity 
    + 0.1 * wind_speed 
    + np.random.normal(0, 1, 500)   # noise
)
solar_output = np.clip(solar_output, 0.5, 8.0)  # realistic bounds (kWh)
df = pd.DataFrame({                                                                                                            
    "temperature": temperature,
    "humidity": humidity,                                                                                                      7
    "wind_speed": wind_speed,
    "solar_output": solar_output
})
# 2. Regression Target & Classification Labels
def categorize_output(val):
    if val < 2.5:
        return "Low"
    elif 2.5 <= val < 5:
        return "Medium"
    else:
        return "High"
df["solar_class"] = df["solar_output"].apply(categorize_output)
X = df[["temperature", "humidity", "wind_speed"]]
y_reg = df["solar_output"]
y_class = df["solar_class"]
# 3. Train-Test Split
X_train, X_test, y_train_reg, y_test_reg = train_test_split(X, y_reg, test_size=0.2, random_state=42)
_, X_test_cls, _, y_test_cls = train_test_split(X, y_class, test_size=0.2, random_state=42)
# 4. Regression Model (Random Forest with Cross-Validation)
reg_model = RandomForestRegressor(n_estimators=200, random_state=42)                   
reg_model.fit(X_train, y_train_reg)
y_pred_reg = reg_model.predict(X_test)
print("ðŸ”¹ Regression Metrics:")
print("MSE:", mean_squared_error(y_test_reg, y_pred_reg))                                            
print("R2 Score:", r2_score(y_test_reg, y_pred_reg))
cv_scores = cross_val_score(reg_model, X, y_reg, cv=5, scoring="r2")
print("Cross-Validation R2 (avg):", cv_scores.mean())
# 5. Direct Classification Model
clf = RandomForestClassifier(n_estimators=200, random_state=42)
clf.fit(X_train, y_train_reg.apply(categorize_output))
y_pred_class = clf.predict(X_test_cls)
print("\nðŸ”¹ Classification Metrics:")
print("Accuracy:", accuracy_score(y_test_cls, y_pred_class))
# 6. Results Table
results = pd.DataFrame({
    "Actual_Output": y_test_reg.values[:10],
    "Predicted_Output": y_pred_reg[:10],
    "Actual_Class": y_test_cls.values[:10],
    "Predicted_Class": y_pred_class[:10]
})
print("\nSample Results (first 10 rows):\n", results)
# 7. Visualization                                                                                                                             
plt.figure(figsize=(12, 5))                                                                                                    
# Regression: Actual vs Predicted
plt.subplot(1, 2, 1)
plt.scatter(y_test_reg, y_pred_reg, color='blue', alpha=0.6)
plt.plot([min(y_test_reg), max(y_test_reg)],
         [min(y_test_reg), max(y_test_reg)], 'r--')
plt.xlabel("Actual Solar Output (kWh)")                                                                             
plt.ylabel("Predicted Solar Output (kWh)")
plt.title("Regression: Actual vs Predicted")
# Classification: Actual vs Predicted Classes
plt.subplot(1, 2, 2)
plt.scatter(range(len(y_test_cls)), y_test_cls, color='green', label='Actual Class')
plt.scatter(range(len(y_pred_class)), y_pred_class, color='orange', marker='x', label='Predicted Class')
plt.xlabel("Test Sample Index")
plt.ylabel("Class")
plt.title("Classification Results")
plt.legend()
plt.tight_layout()
plt.show()
